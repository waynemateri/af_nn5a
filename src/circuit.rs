// circuit.rs - define/implement an association/generation neural circuit that uses probablistic Hebbian learning for interneuronal connnection strengths
//Author Wayne Materi
// Nov 2024 - Jan 2025 and beyond
// The Circuit consists of Columns (containing Layers of Neurons with BasicConnections) and of the BasicConnections between the Columns.
// Columns are essentially probabilitistic pattern matchers whose (tunable/learnable) Connections reflect the relevant contributions of input to output. 
// A basic Circuit that associates a perceived pattern, e.g.  like the MINST digits, with a specified label might contain three Columns:
//      -  the Perceptor Column converts the basic (digitized) image into a fairly consistent set of activations      
//      -  the Conceptor Column converts the desired label into a different consistent set of activations
//      -  the Associator Column takes Perceptor and Conceptor outputs and links co-activated neurons to produced a different set of activations
//              Associator output is returned to Perceptor and Conceptor input 
// These are all pattern-matching columns with intra-column Connections for feedforward and feedbackward Connections
// as well as inter-column Connections for the circuit that Associates Perceptor and Conceptor acitivities and 
// for generation of Conceptor output from Perceptor input once the associations have been learned.
// The idea is that output patterns of Perceptor and Conceptor become "associated" so that an output pattern in one "generates" an output pattern in the other that is similar to 
// the pattern that would be generated by the associated input if it were present. Suppose a certain input pattern at the Perceptor (say an MNIST digit image) would normally be associated
// with an certain input label at the Conceptor, leading to specific output activations in each Column. These output activations are then "associated" in the Associator Column and 
// fed back to the Perceptor and Conceptor Columns, so that if a similar Associator output pattern arises later, it will lead to Perceptor and Conceptor output patterns that are similar 
// to when the input patterns are actually present.
// 
//
// A Column is made up of Layers and Connections between neurons in Layers (within a Column and (in a later version) between Columns). 
//      A Layer is a collection of Neurons. Layers in a single Column may (and usually will) contain different numbers of neurons and may connect to other Layers through BasicConnections, 
//      which are defined in the Column (for intra-Column BasicConnections).
//          A single Layer can contain 0 to n BasicConnections (in a Vec) and BasicConnections may be within the Layer, within the Column, or between Columns. 
//              The from_layer is specifed in the Interface, but the to_layer is the owning Layer of the Interface, so does not need to be specified0.
//          BasicConnections specify both BasicConnection strengths (weights) and whether or not a BasicConnection is even active (through boolean masks).
//          We separate Excitatory and Inhibitory BasicConnections. All BasicConnections strengths in Excitatory BasicConnections are positive, while those in Inhibitory BasicConnections are negative.


use std::f32::consts::PI;

use std::rc::Rc;
use std::cell::RefCell;

use num_integer::Roots;
use rand::distributions::{Distribution, Uniform};

use arrayfire as af;
use af::*;


use std::ops::{Bound, RangeBounds};
pub const MIN_STARTING_WEIGHT: f32 =  -1.0; // To constrain weights during adjustments
pub const MAX_STARTING_WEIGHT: f32 = 1.0; 

const MIN_WEIGHT: f32 =  -1.0; // To constrain weights during adjustments
const MAX_WEIGHT: f32 = 1.0; 

pub const DEFAULT_LEARNING_RATE: f32 = 1.0;
const MIN_ACTIVATION: f32 = 0.0;  
const MAX_ACTIVATION: f32 = PI;  


// We define a variety of constants for certain activity thresholds for sigmoid values
const INACTIVE_SIGMOID: f32 = 0.0415;  // a sigmoid value below which a neuron is considered inactive ( = 1/(1+e^-PI(x-1)); when x = 0 )
const MINIMALLY_ACTIVE_SIGMOID: f32 = 0.25; 
const FULLY_ACTIVE_SIGMOID: f32 = 0.5;  // a sigmoid value above which a neuron is considered normally fully active
const MAXIMALLY_ACTIVE_SIGMOID:f32 = 0.9989; // modified sigmoid when a neuron is maximally active ( = 1/(1+e^-PI(x-1)); when x = PI )

/*#[derive(Clone)]
// TODO not implemented in this version 
pub struct Brain {
    id: usize, // A unique ID (within a Brain)for this Circuit
    circuits: Vec<Rc<RefCell<Circuit>>>,  // Sort this by column id. Circuits in a Brain can be threadsafe b/c of connection Priorities.
    connections: Vec<Connection>,     // The connections Vec is sorted by Priority within the Brain (lowest to highest) for processing.
    last_column_id: usize,    // used when auto-assigning column IDs. Defaults to 0.
}*/

#[derive(Clone)]
pub struct Circuit {
    id: usize, // A unique ID (within a Brain)for this Circuit
    columns: Vec<Rc<RefCell<Column>>>,  // Sort this by column id. Columns in a circuit can be threadsafe b/c of connection Priorities.
    connections: Vec<Connection>,     // The connections Vec is sorted by Priority within the Circuit (lowest to highest) for processing.
    last_column_id: usize,    // used when auto-assigning column IDs. Defaults to 0.
}


#[derive(Clone)]
pub struct Column {
    owning_circuit_id: usize,   // the Circuit that owns this Column
    id: usize, // A unique ID (within a Circuit)for this Column
    layers: Vec<Rc<RefCell<Layer>>>,  // Sort this by layer id (Lowest/Input to Highest/Output). Layers in a column are never threadsafe
    connections: Vec<Connection>,     // The connections Vec is sorted by Priority within the Column (lowest/first to highest) for processing.
    last_layer_id: usize,     // Used when auto-assigning layer IDs
}


#[derive(Clone)]
pub struct Layer {    
    owning_circuit_id: usize,   // the Circuit that owns this Column
    owning_column_id: usize,   // the Column that owns this Layer
    id: usize,                    // A unique ID (within a Column) for this Layer. id runs from input (lowest) to output (highest) 
    two_d_dims: (u64, u64),       // (rows, cols) being represented in this linear format
    activations: af::Array<f32>,  // The activation of a neuron in layer l = PI * Sum(all masked BasicConnection strengths * sigmoids of from_neurons) 
    sigmoids: af::Array<f32>,     // sigmoid of activations. In this model we use sigmoid = 1/(1+e^-PI(x-1))
}

type Priority = usize;
type Id = usize; 

#[derive(Clone)]
pub enum Connection {
    // Connections are stored within a component (eg. Column) for the internal component's (e.g. Layers) of that owning component.
    // So a Circuit contains the connections between its component Columns and some 'SubComponent' Connections that indicate to process
    // the connections of the identified Column, and the Brain 'SubComponent' type Connection indicates to process the connections of the identified Circuit.
    // Columns only have defined Connections between the Layers within the Column and have no SubComponent Connections, as there are no 
    // SubComponents (with defined Connections) below Layers.
    // 
    //Priority is used to determine order of processing withing the column, circuit, or brain
    SubComponent (Priority, Id) ,  // This specifies to go "down a level" and process all the connections in the next lower data structure
                            // i.e. Connections of the sub-components of the current data structure
                            // e.g. If currently processing some BasicConnections within a Circuit (i.e. b/n Columns of that Circuit)
                            // then, reaching Interior will move to processing the BasicConnections *within* a Column (b/n Layers of that Column)
                            // Id is the ID of the lower data structure (e.g. column id or circuit id)
    Internal (Priority, Rc<RefCell<BasicConnection>>), // The Arc<Mutex<BasicConnection>> can be used for parallel processing
                                                    // But, for now, we'll use Rc<RefCell<>> for simplicity
}

#[derive(Clone)]
pub struct BasicConnection {
    // A BasicConnection between any two Layers, in any two Columns and/or Circuits
    to_circuit_id: usize,    // the Circuit that the BasicConnection goes to
    to_column_id: usize,     // the Column that the BasicConnection goes to
    to_layer_id: usize,      // the Layer that the BasicConnection goes to
    
    from_circuit_id: usize,  // the Circuit that the BasicConnection comes from
    from_column_id: usize,   // the Column that the BasicConnection comes from
    from_layer_id: usize,    // the Layer that the BasicConnection comes from

    to_layer: Rc<RefCell<Layer>>,    // the Layer that the BasicConnection goes to. This reference is actually what gets used for access
    from_layer: Rc<RefCell<Layer>>,  // the Layer that the BasicConnection comes from. This reference is actually what gets used for access 
  
    strengths: af::Array<f32>,  // activation weights come from layer l-1 to layer l, where layer 0 = input layer has no act_into_weights
    mask: af::Array<bool>,      // 1.0 for active BasicConnections, 0.0 for inactive BasicConnections
    fields: Vec<FieldDesc>,     // A single BasicConnection description can have more than one Field, each with its own parameters, together producing the mask.
                                // Fields allow us to specify more than one kind of region of BasicConnection, each with its own shape and init_strength
                                // If we alter the kinds (but not the strengths) of a BasicConnection (e.g. during pruning or development), 
                                // we use fields to determine the new mask.
    connection_type: ConnectionType, // When computing activations, this determines if weight * sigmoid is + (Excitatory) or - (Inhibitory). 
                                     // All Connections described by a BasicConnection are of the same connection_type.
    processed_flag: bool, //Used to synchronize BasicConnection processing. TODO Not sure if at connex level or layer level 
}


#[derive(Clone)]
pub enum ConnectionType {
    // used when multiplying activations by BasicConnection strengths  (1.0 for Excitatory and -1.0 for Inhibitory)
    Excitatory,
    Inhibitory,
}

#[derive(Clone,Debug)]
pub struct FieldDesc {
    // A descriptor for a Field
    // Fields are rectangular (sub)regions in the to_layer (considered as a 2D matrix of neurons). 
    // For the purpose of defining Fields, we consider the to_layer to be a 2D matrix of neurons (flattened for implementation).
    // That layer can either be a square or a rectangle. 
    // A single BasicConnection may contain multiple Field definitions, each having their own init_strength and other params

    // Fields specify the range of neurons in a to_layer (see HUB_RADIUS and RIM_RADIUS, below) over which BasicConnections can be made and the proportion of connected neurons within that range.
    // Generally BasicConnections in the to_layer define FIELDS in the layer, which we define as roughly doughnut-shaped regions (hollowed-out rectangles, really)
    // with a HUB_RADIUS (from 0.0..=0.5) and a RIM_RADIUS (from 0.0..=1.0)) always with RIM_RADIUS > HUB_RADIUS.
    
    // WHY do we need Fields
    // If ALL neurons are connected to ALL neurons (e.g. with Complete and Dense BasicConnections for feedforward and/or feed-sideways BasicConnections), then
    // (if we begin with equal weigths for all connnections) it is *impossible* for the system to form distinct associations or to perform any Hebbian learning.
    // Eventually all neurons move toward maximum activation and all BasicConnection.strengths move toward maximums. Outputs all become equal.  
    // In standard gradient descent learning with backpropagation of densely-connected NNs, the weights can begin with the same values as they are error-corrected.

    offset: f32,    // The position of the center of a field in the to_layer relaive to the position of the from_layer neuron.
                    //  0.0: same relative posn, 1.0: start fields at [0,0], other value: offset [rows,cols] proportionally 
                    //  In each case, the fields will start as close to the origin as possible (i.e. within 'spacing' [rows,cols] of the origin), so that
                    //  one field will have the exact posn specified by the offset value. 
    init_strength: f32, // All BasicConnection strengths in a field are initially set to the same value
    hub_radius: f32,    // Fields may not have any BasicConnections to nearby neurons, leaving an unconnected 'hole' in the BasicConnections. 
                        // The hub radius, defines this central area devoid of BasicConnections in terms of proportion of total number of neurons in the to_layer
    rim_radius: f32,    // Fields may include a region in the to_layer that is less than the hole. This proportion (<=1.0) defines the 
                        // outer edge/radius of the field.
    spacing: f32,   // The distance between the center of one field and the center of the next. If 1.0 then each from_neuron only casts one field into the to_layer.
                    // If 0.0 (or some very small number) then each from_neuron casts a field to each to_neuron in the to_layer.
                    // For non-overlapping fields, make this number >= 2 * the rim_radius.
                    // For overlapping fields, make this number < 2 * the rim_radius. 
    connex_coverage: f32, // The proportion of from_layer neurons that are connected to each to_layer field
}

// Because Field has so many elements in the struct, and because there are some common cases, we define an enum FieldWidth with pub constants for the most common cases, like 
// IMMEDIATE_FIELD_WIDTH, NARROW_FIELD_WIDTH, MEDIUM_FIELD_WIDTH, BROAD_FIELD_WIDTH, and LAYER_FIELD_WIDTH.
// In calculating the positioning and spacing of a Field, we use the 2D dimensions of the from_layer and to_layer which are written as proportions of the total number of neurons in that layer.
// e.g. for a (100, 100) neuron layer connected to a (50,50) layer, looking at the from_layer neuron at (20, 30), e.g. at relative posns (0.20, 0.30), an IMMEDIATE_FIELD_WIDTH
// will be centered at relative posn (10, 15), have a 0.0 hub_radius (meaning it connects even to the neurons in the centre/hub of the Field),
// a 0.1 rim_radius (meaning it only connects to neurons within 10% of the (10,15) posn in the to_layer, i.e. within +/-(1.0, 1.5) neurons away from the (10, 15) center).
// It will connect to *all* neurons in that Field (connex_coverage = 1.0), and will be initialized with a standard DFLT_INIT_FIELD_STRENGTH 
// With a spacing of 1.0, there will be only one such Field per to_layer. This can be overridden through the fn with_to_field_spacing() before creating the Field. 
// This "relative posn" coordinate system allows layers of different sizes to be consistently connected w/o specifying the exact neuron number. 
//
// The shorthand FieldWidths are::
//      1) IMMEDIATE_FIELD The field connects to a single set of neurons in the to_layer that are immediately adjacent (within 10%) to the relative posn of the from_layer neuron. No center hole/gap.
//      2) NARROW_FIELD: The field connects to a set of neurons in the to_layer that are within 20% - 40% of the relative posn of the from_layer neuron. No center hole/gap.
//      3) MEDIUM_FIELD: The field connects to a set of neurons in the to_layer that are within 10% - 40% of the relative posn of the from_layer neuron. No center hole/gap. 
//      4) BROAD_FIELD: The field connects to a set of neurons in the to_layer that are within 60% of the relative posn of the from_layer neuron. No center hole/gap.
//      5) LAYER_FIELD: The field connects to all neurons in the to_layer 
//      6) DIRECT_FIELD: The field connects to a single set of neurons in the to_layer that are equivalent to the relative posn of the from_layer neuron. No center hole/gap.
// Changes in spacing, init_strength, hub_radius, rim_radius, and connex_coverage can be made after creating the Field, but before using it to make a BasicConnection.mask.

#[derive(Clone)]
pub enum FieldWidth {
    Immediate,
    Narrow,
    Medium,
    Broad,
    LayerWide,
    Direct,
}

const DFLT_INIT_FIELD_STRENGTH: f32 = 0.01;

const IMMEDIATE_FIELD:FieldDesc= FieldDesc { offset: 0.0, spacing: 1.0, init_strength: DFLT_INIT_FIELD_STRENGTH, hub_radius: 0.0, rim_radius: 0.01, connex_coverage: 1.0 };
const NARROW_FIELD:FieldDesc= FieldDesc    { offset: 0.0, spacing: 1.0, init_strength: DFLT_INIT_FIELD_STRENGTH, hub_radius: 0.05, rim_radius: 0.1, connex_coverage: 1.0 };
const MEDIUM_FIELD:FieldDesc= FieldDesc    { offset: 0.0, spacing: 1.0, init_strength: DFLT_INIT_FIELD_STRENGTH, hub_radius: 0.05, rim_radius: 0.25, connex_coverage: 1.0 };
const BROAD_FIELD:FieldDesc= FieldDesc     { offset: 0.0, spacing: 1.0, init_strength: DFLT_INIT_FIELD_STRENGTH, hub_radius: 0.1, rim_radius: 0.5, connex_coverage: 1.0 };
const LAYER_FIELD:FieldDesc= FieldDesc     { offset: 0.0, spacing: 1.0, init_strength: DFLT_INIT_FIELD_STRENGTH, hub_radius: 0.0, rim_radius: 1.0, connex_coverage: 1.0 };
const DIRECT_FIELD:FieldDesc= FieldDesc    { offset: 0.0, spacing: 1.0, init_strength: DFLT_INIT_FIELD_STRENGTH, hub_radius: 0.0, rim_radius: 0.0, connex_coverage: 1.0 };


impl Circuit {
    pub fn new(id: usize) -> Circuit {
        Circuit { id, columns: Vec::new(), connections: Vec::new(), last_column_id: 0 }
    }

    pub fn with_column(&mut self, column: Column ) -> &mut Circuit {
        // add a described Column to the circuit. 
        self.override_last_column_id(column.id.max(self.last_column_id));
        self.columns.push(Rc::new(RefCell::new(column)));
        self
    }

    pub fn finalize(&mut self) -> Self {
        // sort self.Connections into processing order
        self.connections.sort_by_key(|connex| match connex {
            Connection::Internal(priority, _) => *priority,
            Connection::SubComponent(priority, _) => *priority,
        });
        self.clone()
    }

    pub fn last_column_id(&self) -> usize {
        self.last_column_id
    }

    pub fn override_last_column_id(&mut self, id: usize) {
        self.last_column_id = id;
    }

    fn incr_last_column_id(&mut self) {
        self.last_column_id += 1;
    }


    pub fn with_connection(&mut self, from_column_id:usize, from_layer_id: usize, to_column_id:usize, to_layer_id: usize, priority: usize, connex_type: ConnectionType, fields: &Vec<FieldDesc> )
            -> &mut Circuit {
            println!("Inside Circuit with_connection from Layer {} of Column {} to Layer {} of Column {} in Circuit {}", from_layer_id, from_column_id,to_layer_id, to_column_id , self.id);
            let to_column = self.columns.iter().find(|column| (**column).borrow().id == to_column_id).
                    expect("Could not find specified to Column for internal_connection within Column").clone();
            let from_column = self.columns.iter().find(|column| (**column).borrow().id == from_column_id)
                    .expect("Could not find specified from Layer for internal_connection within Column").clone();
            let to_layer = to_column.borrow().layers.iter().find(|layer| (**layer).borrow().id == to_layer_id).
                    expect("Could not find specified to Layer for internal_connection within Column").clone();
            let from_layer = from_column.borrow().layers.iter().find(|layer| (**layer).borrow().id == from_layer_id)
                    .expect("Could not find specified from Layer for internal_connection within Column").clone();

            println!("Making BasicConnection_from from Layer {} of dims {:?} to Layer {} of dims {:?}", from_layer.borrow().id, from_layer.borrow().two_d_dims, to_layer.borrow().id, to_layer.borrow().two_d_dims); //, self.id);
            let from_id_tuple = (self.id, from_column.borrow().id, from_layer.borrow().id);
            let to_id_tuple = (self.id, to_column.borrow().id, to_layer.borrow().id);
            let new_basic_connection = BasicConnection::new_with_std_fields(to_id_tuple, from_id_tuple, to_layer.clone(), from_layer.clone(), connex_type,  fields);
            self.connections.push(Connection::Internal(priority, Rc::new(RefCell::new(new_basic_connection))));
            println!("In Column {} added BasicConnection from Layer {} to Layer {}", self.id, to_layer.borrow().id, from_layer.borrow().id);
            self
    }

    pub fn with_subcomponent_connection(&mut self, subcomponent_id: usize, priority: usize) -> &mut Circuit {
        println!("Inside Circuit with_subcomponent_connection for Column {} in Circuit {}",  subcomponent_id, self.id);
        let _column_ref = self.columns.iter().find(|column| (**column).borrow().id == subcomponent_id).
                expect("Could not find specified subcomponent Column for internal_connection within Column").clone();
        self.connections.push(Connection::SubComponent(priority, subcomponent_id));
        self
    }

    

}

impl Column {
    pub fn new(id: usize, owning_circuit_id: usize, last_column_id: &mut usize) -> Column {
        *last_column_id = id.max(*last_column_id + 1); //update last_column_id as side effect of creating a new Column in the Circuit
        Column {owning_circuit_id,id, last_layer_id: 0, layers: Vec::new(), connections: Vec::new() }
    }

    pub fn with_layer(&mut self, layer: Layer) -> &mut Column {
        println!("Adding Layer {} to Column", layer.id);
        self.override_last_layer_id(layer.id.max(self.last_layer_id));
        println!("Added Layer {} to Column layers", layer.id);
        self.layers.push(Rc::new(RefCell::new(layer)));
        println!("And put into Column.layers");
        self
    }

    pub fn finalize(&mut self) -> Self {
        // sort self.Connections into processing order
        self.connections.sort_by_key(|connex| match connex {
            Connection::Internal(priority, _) => *priority,
            Connection::SubComponent(priority, _) => *priority,
        });
        self.clone()
    }

    pub fn last_layer_id(&self) -> usize {
        self.last_layer_id
    }

    pub fn override_last_layer_id(&mut self, id: usize) {
        self.last_layer_id = id;
    }

    pub fn with_connection(&mut self, from_layer_id: usize, to_layer_id: usize, priority: usize, connex_type: ConnectionType, fields: &Vec<FieldDesc> )
         -> &mut Column {
        println!("Inside Column with_connection from Layer {} to Layer {} of Column {} in Circuit {}", from_layer_id, to_layer_id, self.id, self.owning_circuit_id);
        let to_layer = self.layers.iter().find(|layer| (**layer).borrow().id == to_layer_id).
                expect("Could not find specified to Layer for internal_connection within Column").clone();
        let from_layer = self.layers.iter().find(|layer| (**layer).borrow().id == from_layer_id)
                .expect("Could not find specified from Layer for internal_connection within Column").clone();
       
        //let from_layer_borrow = from_layer.borrow();
        //let to_layer_borrow_mut = to_layer.borrow_mut();

        println!("Making BasicConnection_from from Layer {} of dims {:?} to Layer {} of dims {:?}", from_layer.borrow().id, from_layer.borrow().two_d_dims, to_layer.borrow().id, to_layer.borrow().two_d_dims); //, self.id);
        let from_id_tuple = (self.owning_circuit_id, self.id, from_layer.borrow().id);
        let to_id_tuple = (self.owning_circuit_id, self.id, to_layer.borrow().id);
        let new_basic_connection = BasicConnection::new_with_std_fields(to_id_tuple, from_id_tuple, to_layer.clone(), from_layer.clone(), connex_type,  fields);
        self.connections.push(Connection::Internal(priority, Rc::new(RefCell::new(new_basic_connection))));
        println!("In Column {} added BasicConnection from Layer {} to Layer {}", self.id, to_layer.borrow().id, from_layer.borrow().id);
        self
    }

}

impl Layer {
    pub fn new_square_layer(id: usize, num_neurons: u64, owning_circuit_id: usize, owning_column_id: usize) -> Layer {
        // return a new Layer with num_neurons, all of Excitatory or Inhibitory type
        println!("Inside new_square_layer for Layer {} of size {}", id, num_neurons);
        let two_d_dims = (num_neurons.sqrt() as u64, num_neurons.sqrt() as u64);
        debug_assert!(num_neurons == two_d_dims.0 * two_d_dims.1, "Number of neurons {} in the layer must be a perfect square or use new_rect_layer()", num_neurons);
        Layer { owning_circuit_id,
                owning_column_id,                
                id,
                two_d_dims,
                activations: af::constant(0.0f32, Dim4::new(&[1, num_neurons, 1, 1])), 
                sigmoids: af::constant(0.0f32, Dim4::new(&[1, num_neurons, 1, 1])), 
        }
    }

    pub fn new_rect_layer(id: usize, num_rows: u64, num_cols: u64, owning_circuit_id: usize, owning_column_id: usize) -> Layer {
        println!("Inside new_rect_layer for Layer {} of size [{},{}]", id, num_rows, num_cols);
        let two_d_dims = (num_rows, num_cols);
        Layer { 
                owning_circuit_id, 
                owning_column_id,                
                id,
                two_d_dims,
                activations: af::constant(0.0f32, Dim4::new(&[1, num_rows * num_cols, 1, 1])), 
                sigmoids: af::constant(0.0f32, Dim4::new(&[1, num_rows * num_cols, 1, 1])), 
        }
    }

    pub fn with_constant_activations(&mut self, value: f32) -> &mut Layer {
        debug_assert!(value >= MIN_ACTIVATION && value <= MAX_ACTIVATION, "Set up Activations must be between {} and {}", MIN_ACTIVATION, MAX_ACTIVATION);
        self.activations = af::constant(value, Dim4::new(&[1, self.activations.dims()[1], 1, 1]));
        self.mod_sigmoids();
        self
    }
    
    /*pub fn with_connection_from(&mut self, from_layer: Rc<RefCell<Layer>>, connex_type: ConnectionType, fields: &Vec<FieldDesc> 
                                            ) -> &mut Layer {
        // Add a BasicConnection to this layer from the from_layer, providing complete specifications for the BasicConnection and all its Fields 
        let from_layer_borrow = from_layer.borrow();

        println!("Inside with_BasicConnection_from from Layer {} of dims {:?} to Layer {} of dims {:?}", from_layer_borrow.id, from_layer_borrow.two_d_dims, self.id, self.two_d_dims); //, self.id);
        let new_basic_connection = BasicConnection::new_with_std_fields(&self, from_layer.clone(), connex_type, connex_dir, fields);
        self.connections.push(new_basic_connection);
        println!("Added BasicConnection from Layer {} to Layer {}", self.id, from_layer.borrow().id);
        self
    }*/

    fn mod_sigmoids(&mut self) {
        // calculate a modified sigmoid of the activations for this layer and place in self.sigmoids (side effect only)
        // The modified sigmoid is 1/(1+e^-PI(activations-1)), which gives a range of 0..=1.0
        // but a range of 0.0415..=0.9989 when activations are in the range 0..=PI
        self.sigmoids = 1.0f32/(1.0f32 + &af::exp(&(-PI as f32 * (&self.activations - 1.0f32))));
    }

    pub fn finalize(&mut self) -> Self {
        self.clone()
    }


}

impl BasicConnection {
    pub fn new_with_std_fields(to_ids: (usize, usize, usize), from_ids: (usize, usize, usize), to_layer: Rc<RefCell<Layer>>, 
                                        from_layer: Rc<RefCell<Layer>>, connex_type: ConnectionType,fields: &Vec<FieldDesc>) -> BasicConnection {
        // create a new BasicConnection from from_layer to this layer to_layer and make a mask that reflects all the Fields specifying the BasicConnections.
        // the to_ids and from_ids tuples contain to/from_circuit_id, to/from_column_id, to/from_layer_id

        let from_layer_borrow = from_layer.borrow();
        let to_layer_borrow = to_layer.borrow();
        let strength_array_rows = from_layer_borrow.two_d_dims.0 * from_layer_borrow.two_d_dims.1;
        let strength_array_cols = to_layer_borrow.two_d_dims.0 * to_layer_borrow.two_d_dims.1; 
        println!("Will set a Connection with std fields b/n Layers {} and {} of size [{},{}] and [{},{}]", from_layer_borrow.id, to_layer_borrow.id, 
                                            from_layer_borrow.two_d_dims.0, from_layer_borrow.two_d_dims.1, to_layer_borrow.two_d_dims.0, to_layer_borrow.two_d_dims.1);               
        let strength_array_dims 
            = Dim4::new(&[strength_array_rows, strength_array_cols, 1, 1]);
        //println!("Strength array dims are {:?}", strength_array_dims);
        let mut new_basic_connection = BasicConnection { 
                                                        to_circuit_id: to_ids.0, to_column_id: to_ids.1, to_layer_id: to_ids.2,
                                                        from_circuit_id: from_ids.0, from_column_id: from_ids.1, from_layer_id: from_ids.2,
                                                        strengths: af::constant(0.0, strength_array_dims),
                                                        mask: af::constant(false, strength_array_dims),
                                                        to_layer: to_layer.clone(),
                                                        from_layer: from_layer.clone(),
                                                        fields: fields.clone(),
                                                        connection_type:connex_type,
                                                        processed_flag: false,
                                                    };    
        for next_field in fields {
            //let next_from_layer = (*from_layer);
            //println!("Processing Field {:?}", next_field);
            let new_specd_mask = next_field.make_connection_mask(&*to_layer_borrow, &*from_layer_borrow);
            // Merge new_specd_mask into new_BasicConnection.mask
            //println!("BasicConnection mask created of dims {:?}", new_specd_mask.dims());

            
            //Assign weights to new_specd_mask (0.0 or next_field.init_strength) according to whether mask is false or true for the BasicConnection
            let mut new_field_strengths = af::constant(next_field.init_strength, new_basic_connection.strengths.dims());
            //println!("Merging new_specd_mask of dims {:?} and a const Array of dims {:?} into new_field_strengths of dims {:?}",
            //            af::constant(0.0, new_specd_mask.dims()).dims(), new_specd_mask.dims(), new_field_strengths.dims());

            // wherever new_specd_mask is true (i.e. in the field), leave new_field_strengths at its init_strength, else set to 0.0 
            new_field_strengths = af::select(&new_field_strengths, &new_specd_mask, &af::constant(0.0, new_specd_mask.dims()));
            
            //Merge new_field_strengths for Field into new_BasicConnection.strengths (use whichever is biggest)
            new_basic_connection.strengths = af::maxof(&new_basic_connection.strengths, &new_field_strengths, false);
            // then merge new mask with existing mask  
            new_basic_connection.mask = af::or(&new_basic_connection.mask, &new_specd_mask, false);           
            
            //println!("Field processed");
            //wait_for_enter();
        }
        new_basic_connection
    }

}

impl FieldDesc {
    pub fn new(offset: f32, spacing: f32, init_strength: f32, hub_radius: f32, rim_radius: f32, connex_coverage: f32) -> FieldDesc {
        FieldDesc { offset, spacing, init_strength, hub_radius, rim_radius, connex_coverage }
    }

    pub fn new_std(field_width:FieldWidth) -> FieldDesc {
        // Create a new field with one of the standard FieldWidths
        match field_width {
            FieldWidth::Immediate => IMMEDIATE_FIELD,
            FieldWidth::Narrow => NARROW_FIELD,
            FieldWidth::Medium => MEDIUM_FIELD,
            FieldWidth::Broad => BROAD_FIELD,
            FieldWidth::LayerWide => LAYER_FIELD,
            FieldWidth::Direct => DIRECT_FIELD,
        }
   
    }
    fn make_connection_mask(&self, to_layer: &Layer, from_layer: &Layer) -> af::Array<bool> {
        // make a new BasicConnection mask that has the same dimensions as BasicConnections.strength (for mask overlay/mult)    
        // This will have the dimensions of rows of from_layer by columns of to_layer
        // It will be all 'false' except where the BasicConnections are active, which will be 'true' from the hub_radius to the rim_radius for 
        // connex_coverage proportion of the field.
        // Remember: Each neural layer is a "flattened" Array, so that BasicConnections from l = [1,10,1,1] to l1 = [1,20,1,1] is in a strengths Array of [10,20,1,1]
        // So the corresponding mask is an Array of [10,20,1,1] like the strengths, where a 'true' in posn[i,j] means the BasicConnection from l[i] to l1[j] is active
        // For convenience in matrix manipulation, I use a rust 2D vector to represent the mask at first
        
        // First a bunch of error checking for the field parameters. Could change these to return a Result<> for proper error checking
        let err_in_offset = self.offset >= 0.0 && self.offset <= 1.0;
        debug_assert!(err_in_offset, "Offset must be between 0.0 and 1.0");
        let err_in_spacing = self.spacing >= 0.0 && self.spacing <= 1.0;
        debug_assert!(err_in_spacing, "Spacing must be between 0.0 and 1.0");        
        let err_in_hub = self.hub_radius >= 0.0 && self.hub_radius <= 0.5;
        debug_assert!(err_in_hub, "Hub radius must be between 0.0 (no  hole) and 0.5");
        let err_in_rim = self.rim_radius >= self.hub_radius && self.rim_radius <= 1.0;
        debug_assert!(err_in_rim, "Rim radius must be between Hub radius and 1.0");
        let err_in_cov = self.connex_coverage >= 0.0 && self.connex_coverage <= 1.0;
        debug_assert!(err_in_cov, "Connection coverage must be between 0.0 and 1.0");

        let (from_rows, from_cols) = (from_layer.two_d_dims.0 as isize, from_layer.two_d_dims.1 as isize);
        let (to_rows, to_cols) = (to_layer.two_d_dims.0 as isize, to_layer.two_d_dims.1 as isize);
        //println!("In make_connection_mask with from_layer of size [{},{}] and to_layer of size [{},{}]", from_rows, from_cols, to_rows, to_cols);

        let connex_mask_rows = (from_rows * from_cols) as usize;
        let connex_mask_cols = (to_rows * to_cols) as usize;
        
        debug_assert!(err_in_offset && err_in_spacing && err_in_hub && err_in_rim && err_in_cov, "For Connection from layer of (rows: {}, cols: {}) to layer of (rows: {}, cols: {})",
                      from_rows, from_cols, to_rows, to_cols);

        
        let (to_hub_radius_rows, to_hub_radius_cols) = ((to_rows as f32 * self.hub_radius).ceil() as isize, (to_cols as f32 * self.hub_radius).ceil() as isize);
        let (to_rim_radius_rows, to_rim_radius_cols) = ((to_rows as f32 * self.rim_radius).ceil() as isize,(to_cols as f32 * self.rim_radius).ceil() as isize);
        
        let mut new_mask: Vec<Vec<bool>> = vec![vec![false; connex_mask_cols]; connex_mask_rows];
        //println!("In make_connection_mask with new_mask = [{},{}]", new_mask.len(), new_mask[0].len());


        // Now set up to get random probabilities
        let mut rng = rand::thread_rng();
        let dist_probs = Uniform::new_inclusive(0.0f32, 1.0);

        
        for from_row in 0..from_rows {
            for from_col in 0..from_cols {
                // Generate a BasicConnection mask for every neuron in the from_layer, translating the FieldDesc(self) parameters into to_layer coordinates 
                
                let to_row_incr = (self.spacing * (to_rows as f32)).max(1.0) as usize;
                let to_col_incr = (self.spacing * (to_cols as f32)).max(1.0) as usize;
                //println!("From  neuron at[{},{}] with spacing at [{},{}]", from_row, from_col, to_row_incr, to_col_incr);

                // Figure out the [starting_to_row, starting_to_col] based on self.offset
                // the starting_to_row and starting_to_col are the center of the Field that is offset from the from_layer neuron (by some number 0..=1.0)
                // then adjusted to find the first such [row, col] such that fields that are self.spacing apart span the entire to_layer and 
                // have one field that matches the offset from the from_layer neuron exactly.
                // So a field coming from the central from_layer neuron will have a starting_to_row of b/n [0,0] and [center, center], in the to_layer
                // depending on self.spacing. Spacing of 0.0 
                let mut starting_to_row: isize = 0;
                let mut starting_to_col: isize = 0;
                
                match self.offset {
                    0.0 if self.spacing == 0.0 => {
                        // just use the relative to_layer posn, b/c  can't do % 0.
                            starting_to_row = (from_row as f32/from_rows as f32 * to_rows as f32) as isize;
                            starting_to_col = (from_col as f32/from_cols as f32 * to_cols as f32) as isize;
                        }
                    1.0 => {
                        // just use [0,0]
                        starting_to_row = 0;
                        starting_to_col = 0;
                         }
                    _ => {
                        // calculate a relative posn using self.offset.
                        // Then adjust to find the first [row,col] such that fields that are self.spacing apart and span the entire to_layer.
                        starting_to_row = (((from_row as f32/from_rows as f32 * to_rows as f32 + self.offset * to_rows as f32) as isize) 
                                                % to_row_incr as isize).max(0);
                        starting_to_col = (((from_col as f32/from_cols as f32 * to_cols as f32 + self.offset * to_cols as f32) as isize) 
                                                % to_col_incr as isize).max(0);
                        }
                }

                
                // For every possible Field coming from this [from_row, from_col] according to self.spacing
                for to_field_center_row in (starting_to_row..to_rows).step_by(to_row_incr) {
                    for to_field_center_col in (starting_to_col..to_cols).step_by(to_col_incr) {
                        //println!("From neuron at [{},{}] To field centered at  [{}, {}] with hub radius [{}, {}] and rim [{}, {}] with spacing incr [{}, {}]", 
                        //            from_row, from_col, to_field_center_row, to_field_center_col,
                        //            to_hub_radius_rows, to_hub_radius_cols, to_rim_radius_rows, to_rim_radius_cols, to_row_incr, to_col_incr);
                
                        for to_row in 
                            (to_field_center_row - to_rim_radius_rows).max(0)..=(to_field_center_row + to_rim_radius_rows).min(to_rows-1) {
                            for to_col in 
                                (to_field_center_col - to_rim_radius_cols).max(0)..=(to_field_center_col + to_rim_radius_cols).min(to_cols-1) {
                                // For every possible neuron in the to_layer Field (as long as inside the to_layer boundaries)
                                // Add a 'true' to the mask if the BasicConnection is active (i.e. if a random_number >= self.connex_coverage)
                                if (to_row <= to_field_center_row - to_hub_radius_rows || to_row >= to_field_center_row + to_hub_radius_rows) ||
                                    (to_col <= to_field_center_col - to_hub_radius_cols || to_col >= to_field_center_col + to_hub_radius_cols) {
                                        //println!("Setting new_mask into [{}, {}] (as Array [{}, {}])", to_row, to_col, (from_row * from_cols + from_col) as usize, (to_row * to_cols + to_col) as usize);
                                        new_mask[(from_row * from_cols + from_col) as usize][(to_row * to_cols  + to_col) as usize] 
                                                    = if dist_probs.sample(&mut rng) <= self.connex_coverage { true } else { false };      
                                } else {
                                    continue; // skip the empty hub part
                                }
                            }
                        }
                    }
                }
                //wait_for_enter();
            }
        }
        let flattened_mask: Vec<_> = new_mask.into_iter().flatten().collect();
        let ret_mask = Array::new(&flattened_mask, Dim4::new(&[(from_rows * from_cols) as u64, (to_rows * to_cols) as u64, 1, 1]));
        ret_mask

    }

}

// Support functions ============================================================================================================================================
fn valid_random_values_range(values_range: impl RangeBounds<f32>) -> Result<(f32, f32), String> {
    // Check that the values_range is a valid range for a uniform dist of random values and return lower and upper bounds    
    let lower = match values_range.start_bound() {
        Bound::Included(candidate) => *candidate,
        Bound::Excluded(_candidate) => 0.0,  // can't really have an Excluded lower bound in a range
        Bound::Unbounded => 0.0,
    };

    let upper = match values_range.end_bound() {
        Bound::Included(candidate) => *candidate,
        Bound::Excluded(candidate) => *candidate - 1.0,
        Bound::Unbounded => std::f32::MAX,
    };

    if lower > upper {
        Err(format!("Upper part of specified random numbers range {} should be >= lower part {}", upper, lower))
    } else {
        Ok((lower, upper))
    }
    
}



use std::io;

pub fn wait_for_enter() {
    let mut press_continue = String::new();
    println!("Hit Enter to continue");
    io::stdin()
        .read_line(&mut press_continue)
        .expect("Nothing entered");
}

